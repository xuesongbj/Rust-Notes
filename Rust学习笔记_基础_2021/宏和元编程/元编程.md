# 元编程

元编程(Metaprogramming)是指某类计算机程序的编写，这类计算机程序编写或者操作其它程序(或者自身)作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高，编写元程序的语言称之为元语言，被操作的语言称之为目标语言。一门语言同时也是自身的元语言的能力称之为反射。

&nbsp;

## 元编程的概念

元编程是一种编程技术，你可以编写能够生产新代码的代码。根据语言的不同，实现的方式有两种:

* **运行时**: 运行时元编程可用于动态语言，例如Python、Javascript及Lisp。
* **编译期**: 编译型语言不可能在运行时生成指令，因为这些语言会执行程序**预编译**。但是你可以选择在编译期生成代码，这是C宏提供的代码。Rust还提供编译期生成功能，它们比C宏的功能更强大、更健壮。

反射是促进元编程的一种很有价值的语言特性。把编程语言自身作为头等对象(Lisp或Rebol)也很有用。支持泛型编程的语言也使用元编程能力。

元编程通常有两种方式起作用:

* 通过API来暴露运行时引擎的内部信息。
* 动态执行包含编程命令的字符串。

&nbsp;

## 元编程_宏

很多语言中，元编程构造通常会用宏表示。通常，宏将任意代码序列作为输入，并输出可由语言编译或执行的有效代码和其他代码。

宏的输入不需要是有效的语法，你可以自由地为宏输入定义的语法。此外，调用宏的方式和定义它们的语法也因语言而异。

```rust
macro_rules! switch {
    ($a: expr, $b: expr) => {
        temp = $b; $b = $a; $a = temp;
    };
}

fn main() {
    let x = 1;
    let y = 2;
    let temp = 3;
    switch!(x, y);
}
```

&nbsp;

如上代码 `switch!`宏对在 `main` 函数中声明的 `temp` 变量一无所知。Rust宏不会从执行环境中捕获变量，因为它与C 宏的工作方式不同。即使它会，我们也将在修改处保存，因为程序中声明的 `temp` 是不可变的。

```rust
$ cargo expand

// 预编译; 宏展开
#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
fn main() {
    let x = 1;
    let y = 2;
    let temp = 3;
    temp = y;
    y = x;
    x = temp;
}
```
