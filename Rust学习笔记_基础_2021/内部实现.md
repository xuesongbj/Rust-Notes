# 内部实现

## The Abstract Machine(抽象机器)

和 `C` 和 `C++`一样，Rust也是基于抽象机器。

&nbsp;

### The abstract machine

* 不是运行时(Runtime)，没有任何运行时开销，它是一种计算模型的抽象
* 包含内存(`stack,...`)、执行语义等概念
* 关注一些CPU可能不关注事情
* 达成程序员和机器之间的约定
* 利用以上规则，进行优化

![abstract machine](./内部实现_img/am.jpg)

&nbsp;

## Language Sugar(语法糖)

* `Coercions`：弱化类型以匹配签名(隐式地强制类型在某些上下文中进行更改)，主要集中在指针和生命周期上。Eg：`&mut T` => `&T`
* `Deref`：解引用
* `Prelude`：自动导入标准库包，eg: `Option`, `Drop`, ...
* `Reborrow`：可以使一个变量同时存在多个可变引用
* `Lifetime Elision`：Rust为了程序可读性，如果你的代码适合省略生命周期规则，可以在函数签名中省略生命周期。
* `Method Resolution`：解引用或借用`x`，`x.f()`
* `Match Ergonomics`：用于模式匹配，目前匹配引用需要使用 `ref` 或者 `&`
* `Rvalue Static Promotion`：引用静态常量

&nbsp;

### Deref(解引用)

```rust
use std::ops::Deref;

struct DerefExample<T> {
    value: T
}

impl<T> Deref for DerefExample<T> {
    type Target = T;

    fn deref(&self) -> &self::Target {
        &self.value
    }
}

let x = DerefExample { value: 'a' };
assert_eq!('a', *x);
```

&nbsp;

### Reborrow

```rust
fn main() {
    let mut s = 11;
    let b = &mut s;
    let c:&mut i32 = b;   // let c = &mut s; -> 会报错，因为这种写法是borrow不是reborrow
    *c = 13;
    *b = 12;
}
```

&nbsp;

### Lifetime Elision

生命周期位置可以显示为**输入**或**输出**。对于 `fn`定义，`fn`类型和`trait Fn`、`FnMut`和`FnOnce`，输入类型是指**形参类型**，而输出指的是**结果类型**。

```rust
// 1. 输入位置省略了一个生命周期
// 2. 输出位置省略了两个生命周期
fn foo(s: &str) -> (&str, &str) {}
```

省略生命周期规则如下：

* 每个参数都有自己的生命周期
* 如果只有一个输入生命周期参数，则该生命周期将分配给所有输出生命周期参数
* 如果多个输入生命周期参数，包含`&self`或`&mut self`，则将`self`生命周期分配给所有省略的输出生命周期

除以上三种情况外，其它情况需要显示指定生命周期。

&nbsp;

#### Example

```rust
fn print(s: &str);                                                                  // 省略
fn print<'a>(s: &'a str);                                                           // 展开

fn debug(lvl: usize, s: &str);                                                      // 省略
fn debug<'a>(lvl: usize, s: &'a str);                                               // 展开

fn substr(s: &str, until: usize) -> &str;                                           // 省略
fn substr<'a>(s: &'a str, util: usize) -> &'a str;                                  // 展开

fn get_str() -> &str;                                                               // 非法的

fn frob(s: &str, t: &str) -> &str;                                                  // 非法的

fn get_mut(&mut self) -> &mut T;                                                    // 省略
fn get_mut<'a>(&'a mut self) -> &'a mut T;                                          // 展开 

fn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command;                          // 省略 
fn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command;         // 展开

fn new(buf: &mut [u8]) -> BufWriter;                                                // 省略 
fn new(buf: &mut [u8]) -> BufWriter<'_>;                                            // 省略
fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>;                                     // 展开 
```

&nbsp;

### Match Ergonomics

```rust
let x &Option<_> = &Some(0);

match x {
    &Some(ref y) => { ... },
    &None => { ... },
}

// or using *:

match *x {
    Some(ref x) => { ... },
    None => { ...},
}
```

* Rust Issue: [rust-lang/rust#42640](https://github.com/rust-lang/rust/issues/42640)

该问题修复后，可以使用以下简单方法:

```rust
let x: &Option<_> = &Some(0);

match x {
    Some(y) => { ... },    // `y` is a reference to `0`
    NOne => { ... },
}
```

&nbsp;

### Rvalue Static Promotion

如果想让表达式值存储在静态内存中，而不是在stack中，可以使用 `'static` 进行创建:

```rust
let x: &'static u32 = &42;
```

&nbsp;

在处理常量值时，必须显式定义常量或`'static`，以创建具有静态生命周期的引用。

```rust
fn generic<T>() -> &'static Option<T> {
    const X: &'static Option<T> = &None::<T>;
    X
}
```
