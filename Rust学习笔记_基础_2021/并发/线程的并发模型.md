# 线程的并发模型

使用线程的主要目的是执行可以拆分为多个子问题的任务，其中线程可能需要彼此通信或共享数据。

Rust 并不会倾向于使用任何固有的并发模型，允许开发者使用自己的模型，并根据需要使用第三方软件包来解决自己的问题。在社区还有一些第三方并发模型供用户选择，其中包括[actix](https://github.com/actix/actix) 实现了actor并发模型；[rayon](https://github.com/rayon-rs/rayon) 实现了 Worker-stealing并发模型；[crossbeam](https://github.com/crossbeam-rs/crossbeam)软件模型，它们允许并发线程从父线程stack共享数据，并保证父线程stack被释放之前返回。

&nbsp;

## 状态共享模型

通过共享状态将值传递给线程是最普遍的做法，并且实现此目的的同步方式存在大多数主流语言中。

`Rc` 类型并不是线程安全的，因为引用计数更新操作不是原子的。我们只能在单线程中使用 `Rc` 类型。如果想在多线程环境共享相同类型所有权，那么需要使用 `Arc` 类型，它和 `Rc` 类型类似，但是具有原子引用计数功能。

&nbsp;

### 通过Arc类型共享所有权

```rust
use std::thread;
use std::sync::Arc;

fn main() {
    let nums = Arc::new(vec![0, 1, 2, 3, 4]);
    let mut childs = vec![];

    for n in 0..5 {
        // 提供了一个包含所有权的 Arc<Vec<i32>> 值
        let ns = Arc::clone(&nums);
        let c = thread::spawn(move || {
            println!("{}", ns[n]);
        });

        childs.push(c);
    }
}
```

&nbsp;

## 互斥

当需要安全地对共享资源进行可变访问时，可以通过互斥提供访问。通常，互斥锁是一个守护对象，线程获取对象以保护要由多个线程或修改的数据。它的工作原理是通过锁定值来禁止一次访问多个线程中的值。如果其中一个线程对互斥锁类型执行了锁定，那么任何其它线程都不能运行相同的代码，直到持有该锁定的线程完成为止。

```rust
use std::thread;
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(0);
    let c = thread::spawn(move || {
        *m.lock().unwrap() += 1;
        let updated = *m.lock().unwrap();
        updated
    });
    let updated = c.join().unwrap();
    println!("{:?}", updated);
}
```