# 线程安全

线程其实是对底层硬件运行过程的直接抽象，这种抽象有优缺点:

* 优点

很多编程语言都对其提供了支持，并且没有对其使用方式加以限制，开发者可以自由实现多线程并发程序，充分利用多核。

&nbsp;

* 缺点

    * 线程的调度完全由系统内核来控制(Linux内核中的调度单位是task)，完全随机，这会导致多个线程的运行顺序是完全无法预测的，有可能产生奇怪的结果。

    * 编写正确的多线程并发程序对开发者要求太高，对多线程变成没有充足知识储备的开发者很容易写满Bug的多线程代码，并且很难重现和调试。

多线程存在的那问题主要是因为资源共享，比如共享内存、文件、数据库等。一个方法、数据结果或库在多线程环境中不会出现任何问题，则可以称之为线程安全。所以多线程的重点就是如何写出县线程安全的代码。

&nbsp;

## 竞态条件与临界区

当某个计算的正确性取决于多个线程交替执行的顺序时，就会产生**竞态条件(Race Condition)**。最常见竞态条件类型是“读取-修改-写入” 和 “先检查后执行”。产生竞态条件的区域，就叫做“临界区”。

```rust
static mut V: i32 = 0;
fn unsafe_seq() -> i32 {
    // Rust中默认不允许修改静态变量的值，所以需要在unsafe块中进行操作
    unsafe {
        V += 1;
        V
    }
}
```

&nbsp;

### 数据竞争

「数据竞争」这个术语很容易和「竞态条件」混淆。当一个线程写一个变量而另一个线程读这个变量时，如果这两个线程没有进行同步，则会发生数据竞争，最终导致读到的数据是错误的。**并非所有的竞态条件都是数据竞争，也并非所有的数据竞争都是竞态条件**。

```rust
// 通过atomic块将整个函数的执行过程赋予原子性，这样就消除了数据竞争和竞态条件
trans3(amount, account_from, account_to) {
    atomic {
        if (account_from.balance < amount) return FALSE;
        account_to.balance += amount;
        account_from.balance -= amount;
        return True;
    }
}
```