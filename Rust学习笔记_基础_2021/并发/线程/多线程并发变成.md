# 多线程并发编程

* `线程管理`，在 `std::thread` 模块中定义了管理线程的各种函数和一些底层同步原语。
* `线程同步`，在 `std::sync` 模块中定义了锁、Channel、条件变量和屏障。

&nbsp;

## 线程管理

Rust中的线程是本地线程，每个线程都有自己的栈和本地状态。

```rust
use std::thread;

fn main() {
    let mut v = vec![];

    // 该闭包需要捕获循环变量id, 默认是按引用来捕获的。但这里涉及到生命周期的问题，传递给子线程的闭包有可能存活周期长于当前函数，如果直接传递引用，则可能引起悬垂指针的问题，
    // Rust不允许的。所以使用move关键字强行将捕获变量id的所有权转移到闭包中。
    for id in 0..5 {
        let child = thread::spawn(move || {
            println!("in child: {}", id);
        });
        v.push(child);
    }

    println!("in main: join before");

    // 对数组v进行迭代，调用其中每一个子线程的join方法，就可以让main主线程等待这些子线程执行完毕
    for child in v {
        child.join();
    }

    println!("in main: join after");
}
```

&nbsp;

### 定制线程

直接使用 `thread::spawn` 生成的线程，默认没有名称，并且其栈大小默认2MB。如果想为线程指定名称或者修改默认栈大小，可以使用 `thread::Builder` 结构体来创建可配置的线程。

```rust
use std::panic;
use std::thread::{Builder, current};

fn main() {
    let mut v = vec![];

    for id in 0..5 {
        let thread_name = format!("child-{}", id);
        let size: usize = 3 * 1024;
        let builder = Builder::new().name(thread_name).stack_size(size);
        let child = builder.spawn(move || {
           println!("in child: {}", id);

           // 使用 thread::current函数获取当前线程
           if id == 3 {
                panic::catch_unwind(|| {
                    panic!("oh on!");
                });
                println!("in {} do sm", current().name().unwrap());
           }
        }).unwrap();        // 之前thread::spawn方法返回的是JoinHandle<T>类型，而Builder的spawn方法返回的是Result<Joinhandle<T>>类型，所以这里需要加unwrap方法。
                            // JoinHandle<T> 代表线程与其它线程join权限。

        v.push(child);
    }

    for child in v {
        child.join().unwrap();
    }
}
```

线程的大小与Rust语言无关，这是因为主线程的栈实际上就是进程的栈，由操作系统来决定。修改所生成线程的默认值也可以通过指定环境变量`RUST_MIN_STACK`来完成，但是它的值会被`Builder::stack_size`覆盖。
