# Rust中的资源管理

Rust不需要开发者显示地通过`malloc/new`或`free/delete`之类的函数去分配和回收堆内存。**Rust可以静态地在编译时确定何时需要释放内存，而不需要在运行时确定**。Rust有一套完整的内存管理机制来保证资源的合理利用和良好的性能。

&nbsp;

## 变量和函数

变量有两种：全局变量和局部变量。

全局变量分为常量变量和静态变量。局部变量是指在函数中定义的变量。

&nbsp;

### 常量

常量使用`const`关键字定义，并且需要显示指明类型，只能进行简单赋值，只能使用支持`CTFE`的表达式。**常量没有固定的内存地址，因为其生命周期是全局的，随着程序消亡而消亡，并且会被编译器有效地内联到每个使用到它的地方**。

&nbsp;

### 静态变量

静态变量使用`static`关键字定义，**静态变量的生命周期是全局的，它不会被内联，每个静态变量都有一个固定的内存地址**。

**静态变量资源分配并不是在栈上和堆上，而是和程序代码一起被存储在静态存储区中**。静态存储区是伴随着程序的二进制文件的生成(编译时)被分配的，并且在程序的整个运行期都存在。**Rust中的字符串字面量同样是存储于静态存储区中**。

### 检查声明未初始化的变量

函数中定义的局部变量都会被默认存储在栈中。Rust编译器可以检查未初始化的变量，以保证内存安全。

```rust
fn main() {
    let x: i32;
            // ^ use of possibly-uninitialized `x` 
    println!("{}", x);
}
```

&nbsp;

### 检查分之流程是否存在为初始化的变量

```rust
fn main() {
    let x: i32;
    if true {
        x = 1;
    } else {        // 如果去掉该代码块，编译器会检查出变量x未正确初始化，导致编译失败
        x = 2;
    }
    println!("{}", x);
}
```

&nbsp;

### 空数组或向量可以初始化变量

当变量绑定空的数组或向量时，需要显式指定类型，否则编译器无法推断其类型。

```rust
fn main() {
    let a: Vec<i32> = vec![];
    let b: [i32; 0] = [];
}
```

&nbsp;

### 转移所有权产生了未初始化变量

当将一个已初始化的变量y绑定给另一个变量y2时，Rust会把变量y看作逻辑上的**未初始化变量**。

```rust
fn main() {
    let x = 42;
    let y = Box::new(5);
    println!("{:p}", y);

    let x2 = x;
    let y2 = y;

    // println!("{:p}", y);
                        // ^ value borrowed here after move
}
```

变量 `x` 为原生整数类型，默认存储在栈上。变量`y`属于指针类型，通过`Box::new`方法在堆上分配的内存返回指针，并与`y`绑定，而指针`y`被存储在栈上。

![所有权转移](./imgs/move.png)

`let x2 = x;` 代码让变量`x2`绑定了变量`x`，因为`x`是原生整数类型，实现了 `Copy trait`，所以这里变量`x`并未发生任何变化。

`let y2 = y;` 代码变量`y2`绑定了变量`y`，因为`y`是`Box<T>`指针，并未实现`Copy trait`，所以此时 `y` 的值会移动给`y2`，而变量`y`会被编译器看作一个未初始化的变量，所以当`println!("{:p}", y);`，编译器就会报错。**但是此时如果给`y`再重新绑定一个新值，`y`依然可用，这个过程称为重新初始化。**

像`Box<T>`这样的指针被称为**智能指针**。**使用智能指针，可以让Rust利用栈来隐式自动释放内存，从而避免显式调用`free`之类的函数去释放内存**。

&nbsp;

## 智能指针与RAII

Rust中指针分为3类: 引用、原生指针(裸指针)和智能指针。

引用就是Rust提供的普通指针，用`&`和`& mut` 操作符来创建，形成`&T` 和 `&mut T`。原生指针是指形如`*const T` 和 `*mut T` 这样的类型。

引用和指针类型之间有以下区别:

* 可以通过`as`操作符随意转换,例如：`&T as *const T` 和 `&mut T as *mut T`。
* 原生指针可以在`unsafe` 块下任意使用，不受Rust的安全检查规则的限制，而引用则必须受到编译器安全检查规则的限制。
