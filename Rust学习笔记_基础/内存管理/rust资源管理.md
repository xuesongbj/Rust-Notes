# Rust中的资源管理

Rust不需要开发者显示地通过`malloc/new`或`free/delete`之类的函数去分配和回收堆内存。**Rust可以静态地在编译时确定何时需要释放内存，而不需要在运行时确定**。Rust有一套完整的内存管理机制来保证资源的合理利用和良好的性能。

&nbsp;

## 变量和函数

变量有两种：全局变量和局部变量。

全局变量分为常量变量和静态变量。局部变量是指在函数中定义的变量。

&nbsp;

### 常量

常量使用`const`关键字定义，并且需要显示指明类型，只能进行简单赋值，只能使用支持`CTFE`的表达式。**常量没有固定的内存地址，因为其生命周期是全局的，随着程序消亡而消亡，并且会被编译器有效地内联到每个使用到它的地方**。

&nbsp;

### 静态变量

静态变量使用`static`关键字定义，**静态变量的生命周期是全局的，它不会被内联，每个静态变量都有一个固定的内存地址**。

**静态变量资源分配并不是在栈上和堆上，而是和程序代码一起被存储在静态存储区中**。静态存储区是伴随着程序的二进制文件的生成(编译时)被分配的，并且在程序的整个运行期都存在。**Rust中的字符串字面量同样是存储于静态存储区中**。

### 检查声明未初始化的变量

函数中定义的局部变量都会被默认存储在栈中。Rust编译器可以检查未初始化的变量，以保证内存安全。

```rust
fn main() {
    let x: i32;
            // ^ use of possibly-uninitialized `x` 
    println!("{}", x);
}
```

&nbsp;

### 检查分之流程是否存在为初始化的变量

```rust
fn main() {
    let x: i32;
    if true {
        x = 1;
    } else {        // 如果去掉该代码块，编译器会检查出变量x未正确初始化，导致编译失败
        x = 2;
    }
    println!("{}", x);
}
```

&nbsp;

### 空数组或向量可以初始化变量

当变量绑定空的数组或向量时，需要显式指定类型，否则编译器无法推断其类型。

```rust
fn main() {
    let a: Vec<i32> = vec![];
    let b: [i32; 0] = [];
}
```

&nbsp;

### 转移所有权产生了未初始化变量

当将一个已初始化的变量y绑定给另一个变量y2时，Rust会把变量y看作逻辑上的**未初始化变量**。

```rust
fn main() {
    let x = 42;
    let y = Box::new(5);
    println!("{:p}", y);

    let x2 = x;
    let y2 = y;

    // println!("{:p}", y);
                        // ^ value borrowed here after move
}
```

变量 `x` 为原生整数类型，默认存储在栈上。变量`y`属于指针类型，通过`Box::new`方法在堆上分配的内存返回指针，并与`y`绑定，而指针`y`被存储在栈上。

![所有权转移](./imgs/move.png)

`let x2 = x;` 代码让变量`x2`绑定了变量`x`，因为`x`是原生整数类型，实现了 `Copy trait`，所以这里变量`x`并未发生任何变化。

`let y2 = y;` 代码变量`y2`绑定了变量`y`，因为`y`是`Box<T>`指针，并未实现`Copy trait`，所以此时 `y` 的值会移动给`y2`，而变量`y`会被编译器看作一个未初始化的变量，所以当`println!("{:p}", y);`，编译器就会报错。**但是此时如果给`y`再重新绑定一个新值，`y`依然可用，这个过程称为重新初始化。**

像`Box<T>`这样的指针被称为**智能指针**。**使用智能指针，可以让Rust利用栈来隐式自动释放内存，从而避免显式调用`free`之类的函数去释放内存**。

&nbsp;

## 智能指针与RAII

Rust中指针分为3类: 引用、原生指针(裸指针)和智能指针。

引用就是Rust提供的普通指针，用`&`和`& mut` 操作符来创建，形成`&T` 和 `&mut T`。原生指针是指形如`*const T` 和 `*mut T` 这样的类型。

引用和指针类型之间有以下区别:
* 可以通过`as`操作符随意转换,例如：`&T as *const T` 和 `&mut T as *mut T`。
* 原生指针可以在`unsafe` 块下任意使用，不受Rust的安全检查规则的限制，而引用则必须受到编译器安全检查规则的限制。

&nbsp;

### 智能指针

智能指针实际上就是一个结构体，只不过它的行为类似指针。智能指针是对指针的一次封装，提供了一些额外的功能，比如自动释放堆内存。

**智能指针区别于常规结构体的特征在于，它实现了`Deref`和`Drop` 这两个trait。`Dref`提供了解引用能力，`Drop`提供了自动析构能力，** 正是这两个`trait`让智能指针拥有了类似指针的行为。

```rust
fn main() {
    let s = String::from("hello");

    // 变量s进行了解引用操作，返回str类型
    // 因为str大小不确定类型，编译器会报错
    // let deref_s: str = *s;

    let v = vec![1,2,3];

    // 变量v解引用，返回[u32]类型
    // 无法确定类型大小，编译器会报错
    // let deref_v: [u32] = *v;
}
```

`String`类型和`Vec`类型的值都是被分配在heap并返回指针的，通过将返回的指针封装来实现`Deref` 和 `Drop`，以自动化管理解引用和释放堆内存。

当`main`函数执行完毕，栈帧释放，变量`s`和`v`被清空之后，对应的已分配内存会被自动释放(因为它们实现了Drop)。

```x86asm
   0x000055555555c388 <+88>:	lea    rdi,[rsp+0x8]
   0x000055555555c38d <+93>:	call   0x55555555d250 <core::ptr::drop_in_place<alloc::string::String>>
   0x000055555555c392 <+98>:	jmp    0x55555555c3bc <eee::main+140>
   0x000055555555c394 <+100>:	mov    rcx,rax
   0x000055555555c397 <+103>:	mov    eax,edx
   0x000055555555c399 <+105>:	mov    QWORD PTR [rsp+0x38],rcx
   0x000055555555c39e <+110>:	mov    DWORD PTR [rsp+0x40],eax
   0x000055555555c3a2 <+114>:	jmp    0x55555555c388 <eee::main+88>
   0x000055555555c3a4 <+116>:	lea    rdi,[rsp+0x20]
   0x000055555555c3a9 <+121>:	call   0x55555555d2b0 <core::ptr::drop_in_place<alloc::vec::Vec<i32>>>          ; Drop Vec
   0x000055555555c3ae <+126>:	jmp    0x55555555c3b0 <eee::main+128>
   0x000055555555c3b0 <+128>:	lea    rdi,[rsp+0x8]
   0x000055555555c3b5 <+133>:	call   0x55555555d250 <core::ptr::drop_in_place<alloc::string::String>>         ; Drop String
   0x000055555555c3ba <+138>:	jmp    0x55555555c3c8 <eee::main+152>
```

`Drop`被执行很重要，他可以帮助智能指针在被丢弃时，自动执行一些重要的清理工作，比如**释放堆内存**。除了可以释放内存，`Drop`还可以做很多其他的工作，比如释放文件和网络连接。

`Drop`的功能有点儿类似GC，但它比GC的应用更加广泛，GC只能回收内存，而`Drop`可以回收内存及内存之外的一切资源。
