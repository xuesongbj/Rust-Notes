# 表达式

Rust是一种表达式语言。

## 声明语句

* let：局部变量。

* item：诸如fn、enum、struct、type、static、trait、impl、mod。

&nbsp;

### 表达式语句

以分号结尾的表达式，表示执行并忽略结果。

```rust
fn test() {}

fn main() {
    let mut a = 1;      // mut可变变量

    let _x = (a = 2);
    let _y = test();    // 返回(),即unit
}
```

```rust
fn main() {
    let _a = {
        let mut x = 1;
        x += 100;
        println!("{:?}", x);

        x           // 注意不能以分号结尾，否则就变成语句了。
    };
}
```

&nbsp;

### if else 表达式

```rust
fn compute(i: i32) -> i32 {
    2 * i
}

fn main() {
    let result_msg = "done";

    // if 表达式赋值
    let result = if result_msg == "done" {
        let some_work = compute(8);
        let stuff = compute(4);
        some_work + compute(2) + stuff
    } else {
        compute(1)
    };

    println!("{}", result);
}
```

&nbsp;

### 声明未初始化变量

Rust 支持声明未初始化的变量，但是我们在使用它们之前需要先对其初始化。如果后续尝试读取未初始化的变量，那么Rust将禁止该操作，并在编译期提示该变量必须初始化。

```rust
fn main() {
    let mut a: i32;             // 声明，未初始化
    println!("{:?}", a);        // 错误 !!!

    a = 23;                     // 正常 !!!
    println!("{:?}", a);        
}
```

```rust
 --> src/main.rs:2:9
  |
2 |     let mut a: i32;
  |         ----^
  |         |
  |         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error[E0381]: borrow of possibly-uninitialized variable: `a`
```

## let 语句

`let` 用于创建新的变量绑定，除了用于变量绑定，`let` 语句还是一个模式匹配语句。

```rust
let a = 23;         // 不可变变量绑定
let mut b = 403;    // 可变变量绑定
```

&nbsp;

### ref关键字

通常会使用运算符 `&` 来创建指向值的引用/指针。创建对任何值的引用的另一种方法是使用带有关键字 `ref` 的let语句。

```rust
#[derive(Debug)]
struct Items(u32);

fn main() {
    let items = Items(2);
    let items_ptr = &items;
    let ref items_ref = items;

    // 转换为 *const Items 是为了比较两个指针是否指向相同的内存地址
    assert_eq!(items_ptr as *const Items, items_ref as *const Items);

    let mut a = Items(20);
    // 通过作用域将b对a的改动限制在内部代码块中
    {
        // 也可以像这样使用可变引用
        let ref mut b = a;      // same as: let b = &mut a;
        b.0 += 25;
    }

    println!("{:?}", items);
    println!("{:?}", a);        // 没有上述作用域限制，代码将无法通过编译
}                               // 因为发生了所有权转移
```

&nbsp;

`ref` 通常不用于声明变量绑定，而主要用于 `match` 表达式中，当我们希望通过引用匹配值时，运算符 `&` 在匹配中不起作用。

```rust
struct Person(String);

fn main() {
    let a = Person("Richard Feynman".to_string());
    match a {
        Person(&name) => println!("{} was a great physicist !", name),
        _ => panic!("Oh no !")
    }

    let _b = a;
}
```

```rust
error[E0308]: mismatched types
 --> src/main.rs:6:16
  |
5 |     match a {
  |           - this expression has type `Person`
6 |         Person(&name) => println!("{} was a great physicist !", name),
  |                ^^^^^
  |                |
  |                expected struct `String`, found reference
  |                help: you can probably remove the explicit borrow: `name`
  |
  = note: expected struct `String`
          found reference `&_`
```

&nbsp;

在 `match` 表达式中使用 `ref`:

```rust
struct Person(String);

fn main() {
    let a = Person("Richard Feynman".to_string());
    match a {
        Person(ref name) => println!("{} was a great physicist !", name),
        _ => panic!("Oh no !")
    }

    let _b = a;
}
```
