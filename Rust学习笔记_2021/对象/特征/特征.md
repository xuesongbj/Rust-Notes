# 特征

特征(trait)是一种定义共享行为方式。类似接口，由函数、类型和常量组成，更允许默认实现。

* 隐式类型参数`Self`，实现此特征的类型。
* 以其它特征约束`Self`，以便在默认实现调用。
* 声明或定义`&self`、`&mut self`、`self`方法。
* 声明或定义类型函数(`Self::function`)。

&nbsp;

* 必须实现提供声明的常量、类型和函数。
* 默认常量、类型和函数实现均可被覆盖。

&nbsp;

```
trait ToInt {
    const SEED: i32;                // 声明常量
    fn new(_: i32) -> Self;         // 声明类型函数
    fn to_int(&self) -> i32;        // 声明实例方法
}

/* ------------------------------------------------------- */

#[derive(Debug)]
struct Data {
    x: i32
}

impl ToInt for Data {
    const SEED: i32 = 100;          // 必须!!!

    fn new(x: i32) -> Self {
        Self{ x }
    }

    fn to_int(&self) -> i32 {
        Self::SEED + self.x
    }
}

fn main() {
    let d = Data::new(1);
    assert_eq!(d.to_int(), 101);
}
```

&nbsp;
&nbsp;

### 覆盖

之所以说像抽象类(abstrace class)，是它可以提供默认实现。

```
use std::fmt::Debug;

trait ToInt where Self: Debug {  // 添加约束。
    fn new(_: i32) -> Self;

    // 默认常量。
    const SEED: i32 = 0;
    
    // 默认方法。
    fn to_int(&self) -> i32 {
        Self::SEED
    }

    fn print(&self) {
        println!("{:?}", self);
    }
}

/* ------------------------------------------------------ */

#[derive(Debug)]
struct Data {
    x: i32
}


impl ToInt for Data {
    fn new(x: i32) -> Self { Self{ x } }
}

/* ------------------------------------------------------ */

fn main() {
    let d = Data::new(10);
    assert_eq!(d.to_int(), 0);
}
```


```
; assert_eq!(d.to_int(), 0);
=> 0x0000555555559275 <+21>:	lea    rdi,[rsp+0x3c]
   0x000055555555927a <+26>:	call   0x5555555591f0 <ddd::ToInt::to_int>
   0x000055555555927f <+31>:	mov    DWORD PTR [rsp+0x54],eax                             // 调用to_int()函数后，将Data{ x } x属性值覆盖为0值 
   0x0000555555559283 <+35>:	lea    rax,[rip+0x31d76]        # 0x55555558b000
   0x000055555555928a <+42>:	lea    rcx,[rsp+0x54]
   0x000055555555928f <+47>:	mov    QWORD PTR [rsp+0x40],rcx
   0x0000555555559294 <+52>:	mov    QWORD PTR [rsp+0x48],rax
   0x0000555555559299 <+57>:	mov    rax,QWORD PTR [rsp+0x40]
   0x000055555555929e <+62>:	mov    QWORD PTR [rsp+0xc8],rax
   0x00005555555592a6 <+70>:	mov    rcx,QWORD PTR [rsp+0x48]                             // 调用to_int()函数返回值将x置为0, rcx=0
   0x00005555555592ab <+75>:	mov    QWORD PTR [rsp+0xd0],rcx
   0x00005555555592b3 <+83>:	cmp    DWORD PTR [rax],0x0                                  // 待比较常量0, rax=0
   0x00005555555592b6 <+86>:	sete   dl
   0x00005555555592b9 <+89>:	xor    dl,0xff
   0x00005555555592bc <+92>:	test   dl,0x1
   0x00005555555592bf <+95>:	mov    QWORD PTR [rsp+0x30],rax                             // rcx == 0
   0x00005555555592c4 <+100>:	mov    QWORD PTR [rsp+0x28],rcx                             // rax == 0
   0x00005555555592c9 <+105>:	jne    0x5555555592d3 <ddd::main+115>                       // assert_eq!比较rcx和rax是否相等

(gdb) p/x $eax
$1 = 0x0

(gdb) disassemble
Dump of assembler code for function ddd::ToInt::to_int:
=> 0x00005555555591f0 <+0>:	push   rax
   0x00005555555591f1 <+1>:	xor    eax,eax                                                  // to_int比较简单，就是将寄存器eax置为0,然后
   0x00005555555591f3 <+3>:	mov    QWORD PTR [rsp],rdi
   0x00005555555591f7 <+7>:	pop    rcx
   0x00005555555591f8 <+8>:	ret
End of assembler dump.
```

&nbsp;

可以覆盖(override)默认实现。(覆盖后无法访问默认实现?)

```
use std::fmt::Debug;

trait ToInt where Self: Debug {
    fn new(_: i32) -> Self;

    const SEED: i32 = 0;

    fn to_int(&self) -> i32 {
        Self::SEED
    }

    fn print(&self) {
        println!("{:?}", self);
    }
}

#[derive(Debug)]
struct Data {
    x: i32
}

impl ToInt for Data {
    fn new(x: i32) -> Self {
        Self { x }
    }

    // 覆盖常量
    const SEED: i32 = 100;
}

fn main() {
    let d = Data::new(10);
    assert_eq!(d.to_int(), 100);
}
```

&nbsp;

```
use std::fmt::Debug;

trait ToInt where Self: Debug {
    fn new(_: i32) -> Self;

    const SEED: i32 = 0;

    fn to_int(&self) -> i32 {
        Self::SEED
    }

    fn print(&self) {
        println!("{:?}", self);
    }
}

#[derive(Debug)]
struct Data {
    x: i32
}

impl ToInt for Data {
    fn new(x: i32) -> Self {
        Self { x }
    }

    // 可以覆盖所有默认定义
    const SEED: i32 = 100;

    fn to_int(&self) -> i32 {
        Self::SEED + self.x
    }
}

fn main() {
    let d = Data::new(10);
    assert_eq!(d.to_int(), 110);
}
```