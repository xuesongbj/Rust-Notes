# 泛型

泛型(generics)是一种类模板技术，允许使用一些在实例化时才指定的类型(参数化类型)。可用于函数、结构体、枚举和方法，极大减少重复代码。

```
#[derive(Debug)]
struct Data<T> {
    x: T
}

fn main() {
    let a = Data{ x: 10 };
    let b = Data{ x: 1.1 };

    assert_eq!(a.x, 10);
    assert_eq!(b.x, 1.1);
}
```

&nbsp;

允许有多个类型参数，如`Result<T, E>`。`T`、`E`只是习惯性用法，可以用其它字母代替。

```
enum Result<A, Z> {
    Ok(A),
    Err(Z),
}
```

&nbsp;
&nbsp;

### 单态化

编译器对泛型进行**单态化**(monomorphization)处理。也就是结合泛型模板和类型参数，生成具体的类型定义。如此，便不会有运行期额外行为，也不会有任何性能损失。

&nbsp;

> 如此，编译后只有 `Data<i32>` 和 `Data<f64>`两个不同类型，并无 `Data<T>`。

&nbsp;

```
(gdb) ptype a
type = struct ddd::Data<i32> {
  x: i32,
}

(gdb) ptype b
type = struct ddd::Data<f64> {
  x: f64,
}
```

&nbsp;

即便是函数，也会生成独立代码。

```
fn test<T>(x: T) -> T {
    x
}

fn main() {
    test(1);
    test("abc");
}
```

```
; test(1);
=> 0x0000555555559271 <+1>:	mov    edi,0x1
   0x0000555555559276 <+6>:	call   0x555555559210 <ddd::test>
   0x000055555555927b <+11>:	lea    rax,[rip+0x31d7e]        # 0x55555558b000

; test("abc");
   0x0000555555559282 <+18>:	mov    rdi,rax
   0x0000555555559285 <+21>:	mov    esi,0x3
   0x000055555555928a <+26>:	call   0x5555555591f0 <ddd::test>

(gdb) disassemble 0x555555559210
Dump of assembler code for function ddd::test:
   0x0000555555559210 <+0>:	sub    rsp,0x4
   0x0000555555559214 <+4>:	mov    DWORD PTR [rsp],edi
   0x0000555555559217 <+7>:	mov    eax,edi
   0x0000555555559219 <+9>:	add    rsp,0x4
   0x000055555555921d <+13>:	ret
End of assembler dump.

(gdb) disassemble 0x5555555591f0
Dump of assembler code for function ddd::test:
   0x00005555555591f0 <+0>:	sub    rsp,0x10
   0x00005555555591f4 <+4>:	mov    QWORD PTR [rsp],rdi
   0x00005555555591f8 <+8>:	mov    QWORD PTR [rsp+0x8],rsi
   0x00005555555591fd <+13>:	mov    rax,rdi
   0x0000555555559200 <+16>:	mov    rdx,rsi
   0x0000555555559203 <+19>:	add    rsp,0x10
   0x0000555555559207 <+23>:	ret
End of assembler dump.
```

&nbsp;
&nbsp;


### 约束

使用特征(trait)约束类型参数，要求其具备指定的功能。如果有多个，则以`+` 号相连。

```
use std::fmt::{Debug, Display};

fn test<T: Debug + Display>(x: T) {
    println!("{}", x);
    println!("{:?}", x);
}

fn main() {
    test(1);
    test("abc");
}
```

&nbsp;

改用 `where` 表达约束，可使代码更为清晰。

```
use std::fmt::{Debug, Display};

fn test<A, B>(x: A, y: B) where
    A: Debug,
    B: Display
{
    println!("{:?}", x);
    println!("{}", y);
}

fn main() {
    test("abc", 12);
}
```

&nbsp;

当然，少不了对泛型结构进行约束。

```
use std::fmt::{Debug};

#[derive(Debug)]
struct Data<T> where
    T: Debug
{
    x: T
}

fn main() {
    let d = Data{x: 1};
    println!("{:?}", d);

    // struct N;
    // let d = Data{x: N};
    //         ^^^^ the trait `Debug` is not implemented for `N`
}
```