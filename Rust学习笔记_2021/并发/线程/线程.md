# 线程

并发体系由标准库，而非语言提供支持。这意味着，可能有很多不同的产品可供选择。标准库以1:1系统线程来提供并发支持，使用方式和其他语言类似。

```rust
use std::thread;

fn main() {
    let handler = thread::spawn(|| {    // 生成一个新的线程, 返回一个 JoinHandle
        for i in 1..10 {
            println!("{}", i);
        }
    });

    handler.join().unwrap();            // join等待子线程执行完成。
                                        // unwrap() 输出具体值
}
```

```rust
use std::thread;

fn main() {
    // Builder: 线程工程，可用于配置新线程属性.
    // new(): 生成线程基本配置
    let builder = thread::Builder::new().name("name".into()).stack_size(20 * 1024);

    let handler = builder.spawn(|| {
        for i in 1..10 {
            println!("{}", i);
        }
    }).unwrap();

    handler.join().unwrap();
}
```

&nbsp;

Builder 线程工厂源码实现：
```
pub struct Builder {
    // 线程名称，目前仅用于出现panic时，区分线程名称.
    name: Option<String>,

    // 线程Stack大小 
    stack_size: Option<usize>,
}
```

&nbsp;

接收闭包函数返回值。

```rust
use std::thread;

fn main() {
    let handler = thread::spawn(|| {
        100
    });

    assert_eq!(handler.join().unwrap(), 100);
}
```

&nbsp;

鉴于不同线程生命周期的差异，强制转移环境变量所有权。

```rust
fn main() {
    let data = vec![1, 2, 3, 4];

    let handler = thread::spawn(move || {
        data.iter().for_each(|d| println!("{:?}", d));
    });

    handler.join().unwrap();
}
```