# 所有权

所有权目的是安全管理内存等资源，及时有效释放。

规则：(ownership rules)

* 每个值（value）都有一个所有者（owner）
* 同一时刻，只能有一个所有者
* 当所有者超出范围（scope），值被删除（drop）

### 转移

赋值、传参和返回值都可能导致所有权转移。

所有权转移(move)后，原绑定失效，不能再次引用。由新拥有者负责释放。

* 如果值可复制（copy），则值传递。
* 其他情况，转移（move）所有权。

```
fn main() {
    let s = String::from("abc");    // heap分配空间

    {
        let s2 = s;                 // Move!!! 所有权转移

        println!("{:?}", s2);
    }

    println!("{:?}", s);            // 所有权已经被转移，所以此处不能再引用
                     ^ value borrowed here after move
}
```

如果对象实现了`Copy`特征，则表示可复制，不存在转移问题。

标量类型实现了复制特征，元素类型实现了`Copy`特征的元组和数组也会复制。

> 注意，`Copy`是隐式调用，`Clone`需要显式调用。

```
fn main() {
    let s = [1, 2, 3, 4];               // 数组实现了Copy操作

    {
        let s2 = s;
        println!("{:?}", s2);
    }

    println!("{:?}", s);
}
```

#### 转移观察

利用反汇编观察转移前后的释放操作。

```
/root/rs/closure/src/main.rs:
1	fn main() {
   0x0000555555559e90 <+0>:	sub    rsp,0x18
   0x0000555555559e94 <+4>:	lea    rax,[rip+0x321ce]        # 0x55555558c069

2	    let _s = String::from("abc");
   0x0000555555559e9b <+11>:	mov    rdi,rsp
   0x0000555555559e9e <+14>:	mov    rsi,rax
   0x0000555555559ea1 <+17>:	mov    edx,0x3
   0x0000555555559ea6 <+22>:	call   0x55555555af20 <<alloc::string::String as core::convert::From<&str>>::from>

3	}
=> 0x0000555555559eab <+27>:	mov    rdi,rsp
   0x0000555555559eae <+30>:	call   0x55555555a720 <core::ptr::drop_in_place>                                // 代码段结束，内存资源释放
   0x0000555555559eb3 <+35>:	add    rsp,0x18
   0x0000555555559eb7 <+39>:	ret
End of assembler dump.
```

> 释放操作是编译器插入的drop_in_place完成的

```
fn main() {
	let s = String::from("abc");

	{
		let _s2 = s;                // 转移
	}                               // 此处释放!

	let _x = 100;                   // 识别外层作用域
}
```


```
/root/rs/closure/src/main.rs:
1	fn main() {
   0x0000555555559e90 <+0>:	sub    rsp,0x38
   0x0000555555559e94 <+4>:	lea    rax,[rip+0x321ce]        # 0x55555558c069

2		let s = String::from("abc");
   0x0000555555559e9b <+11>:	mov    rdi,rsp
   0x0000555555559e9e <+14>:	mov    rsi,rax
   0x0000555555559ea1 <+17>:	mov    edx,0x3
   0x0000555555559ea6 <+22>:	call   0x55555555af40 <<alloc::string::String as core::convert::From<&str>>::from>

3
4		{
5			let _s2 = s;
   0x0000555555559eab <+27>:	mov    rax,QWORD PTR [rsp]
   0x0000555555559eaf <+31>:	mov    QWORD PTR [rsp+0x18],rax
   0x0000555555559eb4 <+36>:	mov    rax,QWORD PTR [rsp+0x8]
   0x0000555555559eb9 <+41>:	mov    QWORD PTR [rsp+0x20],rax
   0x0000555555559ebe <+46>:	mov    rax,QWORD PTR [rsp+0x10]
   0x0000555555559ec3 <+51>:	mov    QWORD PTR [rsp+0x28],rax

6		}
   0x0000555555559ec8 <+56>:	lea    rdi,[rsp+0x18]
   0x0000555555559ecd <+61>:	call   0x55555555a740 <core::ptr::drop_in_place>                        // 此处释放

7
8		let _x = 100;
   0x0000555555559ed2 <+66>:	mov    DWORD PTR [rsp+0x34],0x64

9	}
=> 0x0000555555559eda <+74>:	add    rsp,0x38
   0x0000555555559ede <+78>:	ret
End of assembler dump.
```

> 可以看出，新所有者超出作用域后，立即释放。

转移时，可变性可以改变。

```
fn main() {
    let s = String::from("abc");

    let mut s2 = s;
    s2.push_str("def");

    println!("{:?}", s2);
}
```

```
/root/rs/closure/src/main.rs:
1	fn main() {
   0x000055555555adc0 <+0>:	sub    rsp,0xa8
   0x000055555555adc7 <+7>:	lea    rax,[rip+0x3529b]        # 0x555555590069

2	    let s = String::from("abc");
   0x000055555555adce <+14>:	lea    rdi,[rsp+0x18]
   0x000055555555add3 <+19>:	mov    rsi,rax
   0x000055555555add6 <+22>:	mov    edx,0x3
   0x000055555555addb <+27>:	call   0x55555555caf0 <<alloc::string::String as core::convert::From<&str>>::from>

3
4	    let mut s2 = s;
   0x000055555555ade0 <+32>:	mov    rax,QWORD PTR [rsp+0x28]
   0x000055555555ade5 <+37>:	mov    QWORD PTR [rsp+0x40],rax
   0x000055555555adea <+42>:	movups xmm0,XMMWORD PTR [rsp+0x18]
   0x000055555555adef <+47>:	movaps XMMWORD PTR [rsp+0x30],xmm0

5	    s2.push_str("def");
   0x000055555555adf4 <+52>:	lea    rsi,[rip+0x35271]        # 0x55555559006c
   0x000055555555adfb <+59>:	lea    rdi,[rsp+0x30]
   0x000055555555ae00 <+64>:	mov    edx,0x3
   0x000055555555ae05 <+69>:	call   0x55555555ca50 <alloc::string::String::push_str>
   0x000055555555ae0a <+74>:	jmp    0x55555555ae0c <closure::main+76>
   0x000055555555ae0c <+76>:	lea    rax,[rsp+0x30]

6
7	    println!("{:?}", s2);
   0x000055555555ae11 <+81>:	mov    QWORD PTR [rsp+0x88],rax
   0x000055555555ae19 <+89>:	mov    rax,QWORD PTR [rsp+0x88]
   0x000055555555ae21 <+97>:	mov    QWORD PTR [rsp+0xa0],rax
   0x000055555555ae29 <+105>:	lea    rsi,[rip+0x1b90]        # 0x55555555c9c0 <<alloc::string::String as core::fmt::Debug>::fmt>
   0x000055555555ae30 <+112>:	mov    rdi,rax
   0x000055555555ae33 <+115>:	call   0x55555555cb20 <core::fmt::ArgumentV1::new>
   0x000055555555ae38 <+120>:	mov    QWORD PTR [rsp+0x10],rdx
   0x000055555555ae3d <+125>:	mov    QWORD PTR [rsp+0x8],rax
   0x000055555555ae42 <+130>:	jmp    0x55555555ae44 <closure::main+132>
   0x000055555555ae44 <+132>:	mov    rax,QWORD PTR [rsp+0x8]
   0x000055555555ae49 <+137>:	mov    QWORD PTR [rsp+0x78],rax
   0x000055555555ae4e <+142>:	mov    rcx,QWORD PTR [rsp+0x10]
   0x000055555555ae53 <+147>:	mov    QWORD PTR [rsp+0x80],rcx
   0x000055555555ae5b <+155>:	lea    rsi,[rip+0x446fe]        # 0x55555559f560
   0x000055555555ae62 <+162>:	lea    rdi,[rsp+0x48]
   0x000055555555ae67 <+167>:	mov    edx,0x2
   0x000055555555ae6c <+172>:	lea    rcx,[rsp+0x78]
   0x000055555555ae71 <+177>:	mov    r8d,0x1
   0x000055555555ae77 <+183>:	call   0x55555555c720 <core::fmt::Arguments::new_v1>
   0x000055555555ae7c <+188>:	jmp    0x55555555ae7e <closure::main+190>
   0x000055555555ae7e <+190>:	lea    rax,[rip+0x1659b]        # 0x555555571420 <std::io::stdio::_print>
   0x000055555555ae85 <+197>:	lea    rdi,[rsp+0x48]
   0x000055555555ae8a <+202>:	call   rax
   0x000055555555ae8c <+204>:	jmp    0x55555555ae8e <closure::main+206>

8	}
=> 0x000055555555ae8e <+206>:	lea    rdi,[rsp+0x30]
   0x000055555555ae93 <+211>:	call   0x55555555bd50 <core::ptr::drop_in_place>
   0x000055555555ae98 <+216>:	add    rsp,0xa8
   0x000055555555ae9f <+223>:	ret
   0x000055555555aea0 <+224>:	lea    rdi,[rsp+0x30]
   0x000055555555aea5 <+229>:	call   0x55555555bd50 <core::ptr::drop_in_place>
```

### 复制

Rust 是严格值传递（pass-by-value）语言。

用下面的例子，观察值拷贝，以及所有权转移后的释放问题。

```
#[derive(Debug)]                // 导出结构体，方便调试
struct Data {
    a: i64,
    b: i64,
    c: i64,
    d: i64,
}

// impl Drop：允许我们在值要离开作用域时执行一些代码，
// 可以为任何类型提供`Drop trait`的实现，
// 同时所指定的代码被用于释放类似于文件或网络连接的资源。
impl Drop for Data {             // 实现特征
    fn drop(&mut self) {
        println!("dropping!");
    }
}

fn test(d: Data) {              // 值传递，转移所有权
    let _d = d;
}

fn main() {
    let d = Data{a:0x11, b:0x22, c:0x33, d: 0x44};
    test(d);
}
```

反汇编查看具体实现:
```
(gdb) b 16
(gdb) b 21
(gdb) r

(gdb) disass
19	fn main() {
   0x0000555555559240 <+0>:	sub    rsp,0x48

20		let d = Data{a: 0x11, b:0x22, c:0x33, d:0x44};
   0x0000555555559244 <+4>:	mov    QWORD PTR [rsp+0x8],0x11            --+ +0x8
   0x000055555555924d <+13>:	mov    QWORD PTR [rsp+0x10],0x22         |
   0x0000555555559256 <+22>:	mov    QWORD PTR [rsp+0x18],0x33         |
   0x000055555555925f <+31>:	mov    QWORD PTR [rsp+0x20],0x44       --+ +0x20 + 8

21		test(d);
=> 0x0000555555559268 <+40>:	mov    rax,QWORD PTR [rsp+0x8]
   0x000055555555926d <+45>:	mov    QWORD PTR [rsp+0x28],rax        --+ +0x28
   0x0000555555559272 <+50>:	mov    rax,QWORD PTR [rsp+0x10]          |
   0x0000555555559277 <+55>:	mov    QWORD PTR [rsp+0x30],rax          |
   0x000055555555927c <+60>:	mov    rax,QWORD PTR [rsp+0x18]          | arg: d.copy
   0x0000555555559281 <+65>:	mov    QWORD PTR [rsp+0x38],rax          |
   0x0000555555559286 <+70>:	mov    rax,QWORD PTR [rsp+0x20]          |
   0x000055555555928b <+75>:	mov    QWORD PTR [rsp+0x40],rax        --+ +0x40 + 8


   0x0000555555559290 <+80>:	lea    rdi,[rsp+0x28]                  --> pass d2.addr
   0x0000555555559295 <+85>:	call   0x555555559200 <closure::test>

22	}
   0x000055555555929a <+90>:	add    rsp,0x48
   0x000055555555929e <+94>:	ret
End of assembler dump.

(gdb) b *0x555555559200
(gdb) disassemble
Dump of assembler code for function closure::test:
=> 0x0000555555559200 <+0>:	sub    rsp,0x28
   0x0000555555559204 <+4>:	mov    rax,QWORD PTR [rdi]
   0x0000555555559207 <+7>:	mov    QWORD PTR [rsp+0x8],rax
   0x000055555555920c <+12>:	mov    rax,QWORD PTR [rdi+0x8]
   0x0000555555559210 <+16>:	mov    QWORD PTR [rsp+0x10],rax
   0x0000555555559215 <+21>:	mov    rax,QWORD PTR [rdi+0x10]
   0x0000555555559219 <+25>:	mov    QWORD PTR [rsp+0x18],rax
   0x000055555555921e <+30>:	mov    rax,QWORD PTR [rdi+0x18]
   0x0000555555559222 <+34>:	mov    QWORD PTR [rsp+0x20],rax
   0x0000555555559227 <+39>:	lea    rdi,[rsp+0x8]
   0x000055555555922c <+44>:	call   0x555555559350 <core::ptr::drop_in_place>
   0x0000555555559231 <+49>:	add    rsp,0x28
   0x0000555555559235 <+53>:	ret
End of assembler dump.

(gdb) x/10xg $rsp               # main stack_frame 显然有复制品存在
0x7fffffffe398:	0x000055555555929a	0x00007fffffffe498
0x7fffffffe3a8:	0x0000000000000011	0x0000000000000022
0x7fffffffe3b8:	0x0000000000000033	0x0000000000000044
0x7fffffffe3c8:	0x0000000000000011	0x0000000000000022
0x7fffffffe3d8:	0x0000000000000033	0x0000000000000044
```

实现示意图：

如下图所示，赋值操作由两部分组成, d被分配在`stack`，Data数据分配在`heap`,d指向该数据地址。当调用test函数，则发生了值拷贝(`d2`),d2指向相同heap位置，发生了`所有权转移`。

当发生所有权转移，d变量不可再访问，数据超出test函数作用域，释放资源。

```
Stack               Heap
d --------------->  Data{a:0x11, b:0x22, c:0x33, d: 0x44}
|                  ^
|                  |
|                  |
|                  | 
d.copy --- d2 -----+--> Drop
|
|
d 转移所有权后，d对象失效，不可访问
```

> 可以看出，数据被复制。
> 原数据内存区域不会再访问，也不会执行释放操作。
> 新拥有者负责释放，也就是说drop只会执行一次。

移动(move)和复制(Copy 特征)是有区别的，尽管它们在底层都进行了数据浅拷贝。复制后，原数据对象和复制两个实体都可用。移动则导致原始对象失效，成为“逻辑上未初始化”状态。

尽管所有权、引用、借用等概念导致学习更陡峭的学习曲线，但优点是这些都是编译期行为，并没有额外的运行期负担。最关键的是，在手动和垃圾回收器之间，找到一条性能优秀的资源管理方案。