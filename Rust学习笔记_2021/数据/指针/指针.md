# 指针

很多时候，指针是相对宽泛概念，并非特指**原始指针(raw-pointer)**。以`引用(reference)`为例，在经过编译器检查后，其身上所承担的职责已经卸去。起码在底层指令层面，和原始指针并无区别。所以说它是指针确实算不得错。

**引用和原始指针是独立对象**，间接(*p)操作目标。透过指针修改目标值时，无需声明自身为可变(mut)，除非打算改变自己。

&nbsp;

![](./ptr.png)

&nbsp;

```
fn main() {
    // 要改变的目标，必须是mut。
    let mut x = 100;

    // r: &mut i32，表明目标类型可变。
    let r = &mut x;

    *r+=1;

    // r: &i32, 不可变引用
    let r = &x;
    assert_eq!(*r, 101);
}
```

&nbsp;
&nbsp;

### 原始指针

原始指针分`*mut T`和`*const T`两种，分别对应`可变`和`不可变`。**无论读写都不安全，须自行负责。**

&nbsp;

* *const T : 表示指向类型`T`的不可变原始指针。它是`Copy`类型。类似于`&T`，只是它可以为空值。

* *mut T : 一个指向类型`T`的可变原始指针，它不支持`Copy`特性(non-Copy)。 

```
fn main() {
    let mut x = 100;

    let r: *mut i32 = &mut x;

    unsafe {
        *r += 1;
        assert_eq!(*r, 101);
    }

    let r: *const i32 = &x;
    assert_eq!(unsafe{ *r }, 101);
}
```

&nbsp;

可以和引用相互转换。

```
fn main() {
    let mut x = 100;
    let r = &mut x;

    // 引用转指针必然是安全的。
    let p = r as *mut i32;
    assert_eq!(unsafe{ *p }, x);

    // 指针转回引用就未必安全了。
    let r2: &mut i32 = unsafe{ &mut *p };  // unsafe{ & *p } -> &i32
    *r2 += 1;
    assert_eq!(x, 101);
}
```

```
(gdb) info locals
r2 = 0x7fffffffe2a4
p = 0x7fffffffe2a4
r = 0x7fffffffe2a4
x = 101

// 从底层实现来看，引用和指针没有区别
(gdb) x/xg 0x7fffffffe2a4
0x7fffffffe2a4:	0x0000000000000064

(gdb) x/xg 0x7fffffffe2a4
0x7fffffffe2a4:	0x0000000000000064

// *r2 += 1;
(gdb) x/wx 0x7fffffffe2a4
0x7fffffffe2a4:	0x00000065
```

&nbsp;

可通过`usize`转换，实现指针运算。也正因为如此，指向无法保证。

```
use std::mem::size_of_val;

fn main() {
    let mut x = [1, 2, 3, 4];
    let mut p: *mut i32 = &mut x[0]; // 指针自身和目标都可变。
    
    unsafe {
        assert_eq!(*p, 1);           // 断言x[0]是否等于1

        p = ((p as usize) + size_of_val(&x[0])) as *mut i32; // p++
        *p += 10;
        assert_eq!(*p, 12);
    }
}
```

&nbsp;

原始指针不参与对象生命周期，也就是说可能成为`悬垂指针`。

```
#[derive(Debug)]
struct Data {
    x: i32,
}

impl Drop for Data {
    fn drop(&mut self) {
        println!("Dropping!");
    }
}

fn main() {
    let d = Data{ x: 10 };
    let p = &d as *const Data;

    {
        let _d2 = d;  // move!!!
    }                 // drop!!!

    unsafe {
        println!("{:p}, {:?}", p, *p);
    }
}
```

```
$  cargo r
   Compiling ddd v0.1.0 (/root/rs/ddd)
    Finished dev [unoptimized + debuginfo] target(s) in 3.04s
     Running `/root/rs/ddd/target/debug/ddd`
Dropping!
0x7ffdd34821e4, Data { x: 10 }      # 虽然能返回内容，但这只是因为是栈内存未被覆盖的缘故
```

&nbsp;
&nbsp;

### 智能指针

智能指针(smart-pointer)是一类数据结构，其行为类似指针，拥有额外的功能。与引用的差别在于，引用**借用(borrow)**目标，而智能指针则**拥有(own)**目标。

智能指针通常实现`Deref`和`Drop`特征。`Deref`重载解引用运算符，让它的操作和引用一致；`Drop`则负责在离开作用域时清理资源。

* `Box<T>`: 在堆上分配值。
* `Rc<T>`: 引用计数，可以有多个拥有者。
* `RefCell<T>`: 以不可变引用修改值。

&nbsp;
&nbsp;

#### Box

在堆(heap)上为值分配内存，栈上只是一个指向该内存的指针。

* 单一所有者。
* 运行时才知道所需内存大小。
* 转移所有权时，不想复制数据。

```

   stack              heap
  +=====+           +=======+
  | ptr | --------> | value |    Box<T>
  +=====+           +=======+
```

&nbsp;

和引用一致的使用方式，没有特殊功能。超出作用域自动释放。

```
fn main() {
    
	// 在堆上分配 sizeof(i32) 大小内存，并存储值 5。
    let mut p = Box::new(5);
    
    *p += 1;
    let x: i32 = *p;
    
    assert_eq!(x, 6);
}
```

```
0x0000555555559452 <+18>:	mov    eax,0x4
0x0000555555559457 <+23>:	mov    rdi,rax
0x000055555555945a <+26>:	mov    rsi,rax
0x000055555555945d <+29>:	call   0x555555559730 <alloc::alloc::exchange_malloc>
0x0000555555559462 <+34>:	mov    rcx,rax
0x0000555555559465 <+37>:	mov    DWORD PTR [rax],0x5

; let mut p = Box::new(5);
0x000055555555946b <+43>:	mov    QWORD PTR [rsp+0x60],rcx     // p(stack) -> heap -> 0x00000005

(gdb) info locals
x = 6
p = 0x55555559c9d0

(gdb) x/xw 0x55555559c9d0                                       // 在heap上为值分配内存
0x55555559c9d0:	0x00000006

(gdb) info proc mappings
0x55555559c000     0x5555555bd000    0x21000        0x0 [heap]  // heap内存范围

(gdb) disass                                                    // 超出作用域，所有权自动释放
0x0000555555559630 <+496>:	lea    rdi,[rsp+0x60]
0x0000555555559635 <+501>:	call   0x555555559230 <core::ptr::drop_in_place>
0x000055555555963a <+506>:	mov    rdi,QWORD PTR [rsp+0xf0]
```

```
fn main() {
    // 以数组实现类 calloc 功能。
    let mut p = Box::new([0i64; 10]);

    p[1] = 10;
    p[2] = 20;

    println!("{:?} {:?}", p[2], p);
}
```

```
(gdb) info locals                                               // 数组值被分配在堆上
p = 0x5555555a09d0

(gdb) x/10xg 0x5555555a09d0                                     // heap上值内容
0x5555555a09d0:	0x0000000000000000	0x000000000000000a
0x5555555a09e0:	0x0000000000000014	0x0000000000000000
0x5555555a09f0:	0x0000000000000000	0x0000000000000000
0x5555555a0a00:	0x0000000000000000	0x0000000000000000
0x5555555a0a10:	0x0000000000000000	0x0000000000000000
```

#### Rc

引用计数(reference counting)启用多所有权。当饮用数为`0`时，进行清理。

* 堆分配内存，共享所有权
* 单线程，使用非原子计数
* 不可变引用，无法修改值
* 降级获取没有所有权的弱指针(weak pointer)
* 存在循环引用无法释放的问题(用弱指针解决)


```
use std::rc::Rc;

fn main() {
    let rc = Rc::new(5);
    assert_eq!(Rc::strong_count(&rc), 1);

    {
        // 增加引用，计数 +1
        let rc2 = rc.clone();
        assert_eq!(Rc::strong_count(&rc), 2);

        // 解引用
        assert_eq!(*rc2, 5);
    }   // 超出作用域，计数 -1

    assert_eq!(Rc::strong_count(&rc), 1);
}
```

```
// heap上存储的是RcBox 数据结构
(gdb) info locals
rc = alloc::rc::Rc<i32> {
  ptr: core::ptr::non_null::NonNull<alloc::rc::RcBox<i32>> {
    pointer: 0x55555559d9d0
  },
  phantom: core::marker::PhantomData<alloc::rc::RcBox<i32>>
}

(gdb) x/3xg 0x55555559d9d0
0x55555559d9d0:	0x0000000000000001	0x0000000000000001
0x55555559d9e0:	0x0000000000000005

// Rc::new执行后，rc引用计数为1
(gdb) x/xg 0x55555559f9d0
0x55555559f9d0:	0x0000000000000001

// rc.clone执行后，rc引用计数自加1, 即2
(gdb) c
Continuing.
Breakpoint 2, ddd::main () at /root/rs/ddd/src/main.rs:13
13	        assert_eq!(Rc::strong_count(&rc), 2);

(gdb) x/xg 0x55555559f9d0
0x55555559f9d0:	0x0000000000000002

// 离开rc2作用域，计数器自减1，即1
(gdb) c
Continuing.
Breakpoint 3, ddd::main () at /root/rs/ddd/src/main.rs:18
18	    assert_eq!(Rc::strong_count(&rc), 1);

(gdb) x/xg 0x55555559f9d0
0x55555559f9d0:	0x0000000000000001
```
&nbsp;

源码剖析:

```

   stack              heap
  +=====+           +============+
  | ptr | --------> | strong_cnt |    Rc<T>
  +=====+           +------------+
                    | weak_cnt   |
                    +------------+
                    | value      |
                    +============+
```

```
// library/alloc/src/rc.rs
struct RcBox<T: ?Sized> {
    strong: Cell<usize>,            // 引用计数
    weak: Cell<usize>,              // 弱引用计数
    value: T,                       // 值
}
```

##### 弱引用

```
use std::rc::{Rc, Weak};

fn main() {
    let wr: Weak<i32>;

    {
        let rc = Rc::new(5);

        // 降级, 生成弱引用
        wr = Rc::downgrade(&rc);

        // 不影响强引用计数
        assert_eq!(Rc::strong_count(&rc), 1);
        assert_eq!(Rc::weak_count(&rc), 1);

        // 弱引用不能保证目标值存活，所以不能直接解引用。
        // 升级成强引用再操作。如已释放，返回None。
        if let Some(rc2) = wr.upgrade() {
            assert_eq!(*rc2, 5);
        } else {
            panic!("upgrade: None");
        }
    }   // Rc drop!!!

    assert_eq!(wr.upgrade(), None);
}
```

```
(gdb) info locals
rc = alloc::rc::Rc<i32> {
  ptr: core::ptr::non_null::NonNull<alloc::rc::RcBox<i32>> {
    pointer: 0x5555555a09d0
  },
  phantom: core::marker::PhantomData<alloc::rc::RcBox<i32>>
}

// let rc = Rc::new(5) 引用计数置为1
(gdb) x/xg 0x5555555a09d0
0x5555555a09d0:	0x0000000000000001

// wr = Rc::downgrade(&rc), rc降级为弱引用
// 引用计数不受影响
(gdb) c
Continuing.
Breakpoint 2, ddd::main () at /root/rs/ddd/src/main.rs:15
15	        assert_eq!(Rc::strong_count(&rc), 1);

(gdb) x/xg 0x5555555a09d0
0x5555555a09d0:	0x0000000000000001

// wr.upgrade(), wr升级为强引用
// 引用计数自增1
(gdb) c
Continuing.
Breakpoint 3, ddd::main () at /root/rs/ddd/src/main.rs:19
19	            assert_eq!(*rc2, 5);

(gdb) x/xg 0x5555555a09d0
0x5555555a09d0:	0x0000000000000002

// 超出作用域, 引用计数置为0
(gdb) c
Continuing.
Breakpoint 4, ddd::main () at /root/rs/ddd/src/main.rs:25
25	    assert_eq!(wr.upgrade(), None);

(gdb) x/xg 0x5555555a09d0
0x5555555a09d0:	0x0000000000000000
```

##### 自动解引用

自动解引用，可直接调用值方法。

```
use std::rc::Rc;

struct User {
    age: u8
}

impl User {
    fn test(&self) {
        println!("{}", self.age);
    }
}

fn main() {
    let rc = Rc::new(User{ age: 10 });
    rc.test();
}
```

#### RefCell

**内部可变性**(interior mutability)利用unsafe绕过借用规则，允许通过不可变引用修改内部值。

* 唯一所有权，运行期借用规则检查。
* 运行时行为，出错`panic!`。
* 单线程。

&nbsp;

> 编译器静态规则检查过于保守，某些设计需要运行期操作。 

&nbsp;

```
use std::cell::RefCell;

fn main() {
    let c = RefCell::new(5);

    {
        let r1 = c.borrow();            // &T
        let r2 = c.borrow();            // &T

        assert_eq!(*r1, 5);
        assert_eq!(*r1, *r2);
    }

    {
        let mut r = c.borrow_mut();     // &mut T
        *r = 10;
    }

    assert_eq!(c.into_inner(), 10);     // c 被释放
}
```

```
// RefCell 结构

(gdb) ptype c
type = struct core::cell::RefCell<i32> {
  borrow: core::cell::Cell<isize>,
  value: core::cell::UnsafeCell<i32>,
}

// 结构体示意图

   stack              heap
  +=====+           +============+
  | ptr | --------> | borrow_cnt |    RefCell<T>
  +=====+           +------------+    borrow_mut: count = -1
                    | value      |
                    +============+
                    
```

```
// RefCell::new(5) 初始化后，borrow计数为0

(gdb) info locals
c = core::cell::RefCell<i32> {
  borrow: core::cell::Cell<isize> {
    value: core::cell::UnsafeCell<isize> {
      value: 0
    }
  },
  value: core::cell::UnsafeCell<i32> {
    value: 5
  }
}

(gdb) x/2xg 0x7fffffffe1d0
0x7fffffffe1d0:	0x0000000000000000	0x0000000000000005


// borrow_mut调用borrow_cnt()后，将计数置为-1

c = core::cell::RefCell<i32> {
  borrow: core::cell::Cell<isize> {
    value: core::cell::UnsafeCell<isize> {
      value: -1
    }
  },
  value: core::cell::UnsafeCell<i32> {
    value: 5
  }
}

// 调用borrow_cnt后，结构体发生改变
// let mut r = c.borrow_mut();

(gdb) ptype r
type = struct core::cell::RefMut<i32> {
  value: *mut i32,
  borrow: core::cell::BorrowRefMut,
}

// let mut r = c.borrow_mut(); 后，r变量引用置为负数，可通过r进行修改r指向堆上的值
r = core::cell::RefMut<i32> {
  value: 0x7fffffffe1d8,
  borrow: core::cell::BorrowRefMut {
    borrow: 0x7fffffffe1d0
  }
}

(gdb) x/xg 0x7fffffffe1d8                       // 值
0x7fffffffe1d8:	0x0000000000000005

(gdb) x/xg 0x7fffffffe1d0                       // 一个负数补码
0x7fffffffe1d0:	0xffffffffffffffff
```

&nbsp;

改造`Rc`，使其可变。

&nbsp;

```
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let rc = Rc::new(RefCell::new(5));
    let rc2 = rc.clone();

    {
        let mut r = rc.borrow_mut();
        *r = 100;
    }

    assert_eq!(*rc2.borrow(), 100);
}
```

```
(gdb) info locals
r = core::cell::RefMut<i32> {
  value: 0x55555559f928,
  borrow: core::cell::BorrowRefMut {
    borrow: 0x55555559f920
  }
}

rc2 = alloc::rc::Rc<core::cell::RefCell<i32>> {
  ptr: core::ptr::non_null::NonNull<alloc::rc::RcBox<core::cell::RefCell<i32>>> {
    pointer: 0x55555559f910
  },
  phantom: core::marker::PhantomData<alloc::rc::RcBox<core::cell::RefCell<i32>>>
}

rc = alloc::rc::Rc<core::cell::RefCell<i32>> {
  ptr: core::ptr::non_null::NonNull<alloc::rc::RcBox<core::cell::RefCell<i32>>> {
    pointer: 0x55555559f910
  },
  phantom: core::marker::PhantomData<alloc::rc::RcBox<core::cell::RefCell<i32>>>
}

// let mut r = rc.borrow_mut(), r borrow指向rc2(rc) RefCell.value地址
(gdb) x/4xg 0x55555559f910
0x55555559f910:	0x0000000000000002	0x0000000000000001
0x55555559f920:	0xffffffffffffffff	0x0000000000000005

// *r = 100, 更改r.borrow 指向heap内容，即rc2(rc).value位置的值
(gdb) x/4xg 0x55555559f910
0x55555559f910:	0x0000000000000002	0x0000000000000001
0x55555559f920:	0xffffffffffffffff	0x0000000000000064
```


#### Cell

便捷版本`Cell`，开辟一块儿始终可变内存区域。

* 栈内存分配。
* 仅适合实现`Copy`特征的类型。

```
use std::cell::Cell;

struct Data {
    x: i64,
    y: Cell<i64>,
}

fn main() {
    let d = Data{ x: 1, y: Cell::new(2) };

    // d.x = 10;
    // ^^^^^^^^ cannot assign

    d.y.set(200);
    assert_eq!(d.y.get(), 200);
}
```

```
(gdb) ptype d.y                         // Cell数据类型
type = struct core::cell::Cell<i64> {
  value: core::cell::UnsafeCell<i64>,
}

(gdb) info locals
d = ddd::Data {
  x: 1,
  y: core::cell::Cell<i64> {
    value: core::cell::UnsafeCell<i64> {
      value: 2
    }
  }
}

(gdb) p/x &d                            // 分配在stack
$1 = 0x7fffffffe350

(gdb) x/2xg 0x7fffffffe350
0x7fffffffe350:	0x0000000000000001	0x0000000000000002

(gdb) info proc  mappings
0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
```

```
// d.y.set(200) 实现

0x0000555555559585 <+53>:	mov    rdi,rcx
0x0000555555559588 <+56>:	mov    esi,0xc8
0x000055555555958d <+61>:	call   0x5555555591b0 <core::cell::Cell<T>::set>

(gdb) p/x $rsp+0x40
$1 = 0x7fffffffe350

(gdb) x/2xg  0x7fffffffe350
0x7fffffffe350:	0x0000000000000001	0x00000000000000c8          // 0xc8 被设置为新值
```

```
// 源码剖析

pub fn set(&self, val: T) {
    let old = self.replace(val);    // 设置新值
    drop(old);                      // 删除旧值
}
```

#### RefCell Vs. Cell

`Cell`比`RefCell` 更轻，性能更好，用法更方便... 但是`Cell`只能包装`Copy`类型，而`RefCell`可以包装任何类型，并且`RefCell`可以获取其内部包装对象的引用，并在运行时检测可变引用的唯一性。

具体数据结构:

```
// library/core/src/cell.rs

pub struct Cell<T: ?Sized> {
    value: UnsafeCell<T>,                                                       // 内部对象
}
```

```
// RefCell
type BorrowFlag = isize;

pub struct RefCell<T: ?Sized> {
    borrow: Cell<BorrowFlag>,                                                   // 对象引用类别和计数器
    borrowed_at: Cell<Option<&'static crate::panic::Location<'static>>>,        // 借用最开始&活跃的位置
    value: UnsafeCell<T>,                                                       // 内部对象
}
```

```
// &mut T
pub struct RefMut<'b, T: ?Sized + 'b> {
    value: &'b mut T,
    borrow: BorrowRefMut<'b>,
}
```

`RefCell`内部维护了一个包装对象的引用计数，当`RefCell.borrow`获取一个共享引用时，内部引用计数加1，当获取的引用离开作用域时，内部引用计数减1，当`RefCell.borrow_mut`获取一个可变引用时，首先检测引用计数是否为0，如果为0，正常返回，否则panic；其实`RefCell.borrow`也会做类似的检测，当已经获取了可变引用也是直接panic，当然为了避免panic，我们可以用`RefCell.try_borrow`和`RefCell.try_borrow_mut`来获取一个`Result`类型。

&nbsp;

因为`Cell`和`RefCell`两种类型都未实现`Sync` trait，所以这两种类型只能用于单线程中，不能跨线程操作，如果需要跨线程操作，就需要用到`Mutex`和`RwLock`了。

