# 可恢复错误

可恢复性（recoverable）错误通常指一种状态，比如打开文件时，没找到，应该新建。显然，最终如何处理，由调用方负责。没有异常，对于可恢复性错误，返回`Result<T, E>`对象。

&nbsp;

## Option

Rust中没有 `null` 值的概念，在Rust中，可能失败并希望指示缺失相应值的API会返回 `Option`。当任何API及其后续值想要表示缺少值时，此错误类型就是合适的。简而言之，它与`null`值类似，不过这里的 `null` 值检查是显式的，并且在编译期由类型系统强制执行。

Option包含以下标签签名:

```rust
pub enum Option<T> {
    /// 没有值
    None,

    /// 包含某些值 'T'
    Some(T),
}
```

&nbsp;

它是包含两个变体的枚举，并且 `T` 是泛型。操作成功时，可以使用Some(T)存储任意类型值`T`，或者使用 `None` 变量表示操作失败的情况下该值为null。

```rust
let wrapped_i32 = Some(2);          // Some(T)

let empty: Option<i32> = None;      // None

let empty = None::<i32>;            // None
```

&nbsp;

### prelude模块

Rust的标准库，有一个 `prelude` 子模块，该模块自动导入了常用的类型、函数和任意标准库模块的重新导出。导入后，允许直接通过变体实例话 `Option` 值。

目前版本导入以下内容:

```rust
//! [mem::drop]: crate::mem::drop
//! [std::borrow]: crate::borrow
//! [std::boxed]: crate::boxed
//! [std::clone]: crate::clone
//! [std::cmp]: crate::cmp
//! [std::convert]: crate::convert
//! [std::default]: crate::default
//! [std::iter]: crate::iter
//! [std::marker]: crate::marker
//! [std::mem]: crate::mem
//! [std::ops]: crate::ops
//! [std::option]: crate::option
//! [`std::prelude::v1`]: v1
//! [std::result]: crate::result
//! [std::slice]: crate::slice
//! [std::string]: crate::string
//! [std::vec]: mod@crate::vec
//! [`to_owned`]: crate::borrow::ToOwned::to_owned
//! [book-closures]: ../../book/ch13-01-closures.html
//! [book-dtor]: ../../book/ch15-03-drop.html
//! [book-enums]: ../../book/ch06-01-defining-an-enum.html
//! [book-iter]: ../../book/ch13-02-iterators.html
```

&nbsp;

### Option 交互

如下实例，`value` 是一个 `Option<&i32>`。`get()` 方法返回的是一个 `Option<&i32>`，而不是其内部的值(`&i32`)。为了给 `value`的值加1，我们需要从 `Option`中提取 `i32`。为了检查变体，我们有两种方法，他们分别是 `模式匹配` 和 `if let` 语句。

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert("one", 1);
    map.insert("two", 2);

    let incremented_value = match map.get("one") {
        Some(val) => val + 1,
        None => 0
    };

    println!("{}", incremented_value);
}
```

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert("one", 1);
    map.insert("two", 2);

    let incremented_value = if let Some(v) = map.get("one") {
        v + 1
    } else {
        0
    };

    println!("{}", incremented_value);
}
```

当我们对值的某个变体感兴趣并希望对其他变体进行常规的操作时，推荐使用这种方法。`if let` 语句表述更简洁。

&nbsp;

### Unwrapping

Unwrapping是一种不太安全的方法在 `Option` 上调用解压缩方法。如果返回的结果是 `Some`，那么调用 `unwrap()` 和 `expect()`方法提取内部的值；如果返回的结果是 `None`，则会发生异常。

**仅当我们确定 `Option` 值确实包含某个值时，才推荐使用这些方法。**

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert("one", 1);
    map.insert("two", 2);

    let incremented_value = map.get("two").unwrap() + 1;
    println!("{}", incremented_value);
}
```

`get`一个不存在的**键值**，则发生异常。

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert("one", 1);
    map.insert("two", 2);

    let incremented_value = map.get("three").unwrap() + 1;
    println!("{}", incremented_value);
}
```

```rust
root@8d75790f92f5:~/rs/ddd/src# cargo r
   Compiling ddd v0.1.0 (/root/rs/ddd)
    Finished dev [unoptimized + debuginfo] target(s) in 5.21s
     Running `/root/rs/ddd/target/debug/ddd`
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/main.rs:12:46
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

&nbsp;

#### unwrap() 和 expect() 区别

`expect()` 是首选方法，因为它允许你传递一个字符串作为发生异常时输出的提示信息，同时显示源文件发生异常时的确切代码行号。

`unwrap()` 不允许你将调试信息作为参数进行传递，并显示在标准库源文件中 `Option` 下定义 `unwrap()`的代码行号。

&nbsp;

## Result<T, E>

`Result` 和 `Option` 类似，但具有一些优点，即能够存储和错误上下文有关的异常值，而不只是 `None`。**当我们希望知道操作失败的原因时，此类型是合适的。**

`Result`类型签名:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

它包含两个变体，并且都是泛型。`Ok(T)`是用于表示成功状态时放入任意值 `T` 的变体，而 `Err(E)` 是用于表示执行失败时放入任何异常值 `T`的变体。

```rust
fn main() {
    // Ok(T)
    let _my_result: Result<_, ()> = Ok(64);
    let _my_result = Ok::<_, ()>(64);

    // Err(E)
    let _my_err = Err::<(), f32>(354.3);
    let _other_err: Result<bool, String> = Err("Wait, What ?".to_string());
}
```

使用 `()` 指定 `Err` 变体的类型 `E`。可以使用 `_`来要求Rust为我们推断具体的类型。

&nbsp;

### unwrap

`Result<T, E>` 类型定义了很多辅助方法来处理各种情况，其中之一叫做`unwrap`。

* 如果`Result`值是成员`OK`, `unwrap`会返回`OK`中的值。
* 如果`Result`是成员`Err`，`unwrap`会为我们调用`panic!`。

```rust
use std::fs::File;

fn main() {
    let _f = File::open("hello.txt").unwrap();
}
```

```rust
root@8d75790f92f5:~/rs/closure/src# cargo r
   Compiling closure v0.1.0 (/root/rs/closure)
    Finished dev [unoptimized + debuginfo] target(s) in 3.41s
     Running `/root/rs/closure/target/debug/closure`
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:4:38
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

```rust
// 详细调用栈帧
root@8d75790f92f5:~/rs/closure/src# RUST_BACKTRACE=full cargo r
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `/root/rs/closure/target/debug/closure`
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:4:38
stack backtrace:
   0:     0x55e20fffef10 - std::backtrace_rs::backtrace::libunwind::trace::h25e12e0d899beba0
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/../../backtrace/src/backtrace/libunwind.rs:90:5
   1:     0x55e20fffef10 - std::backtrace_rs::backtrace::trace_unsynchronized::h70e61195d6ae3df6
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5
   2:     0x55e20fffef10 - std::sys_common::backtrace::_print_fmt::hba93ab80d779695a
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/sys_common/backtrace.rs:67:5
   3:     0x55e20fffef10 - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::hf092b5883b4b2e50
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/sys_common/backtrace.rs:46:22
   4:     0x55e2100157fc - core::fmt::write::hf68bc350a8f2f0dc
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/fmt/mod.rs:1078:17
   5:     0x55e20fffd332 - std::io::Write::write_fmt::hf66811b1bc767436
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/io/mod.rs:1517:15
   6:     0x55e210000c45 - std::sys_common::backtrace::_print::hd425a11bfe1f20f8
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/sys_common/backtrace.rs:49:5
   7:     0x55e210000c45 - std::sys_common::backtrace::print::h6d678795c1e61e13
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/sys_common/backtrace.rs:36:9
   8:     0x55e210000c45 - std::panicking::default_hook::{{closure}}::h78a02a4a0dee5e7e
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:208:50
   9:     0x55e21000079a - std::panicking::default_hook::h56eb7eda02f355a7
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:225:9
  10:     0x55e2100013e1 - std::panicking::rust_panic_with_hook::hb27ea14285131c61
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:591:17
  11:     0x55e210000f27 - std::panicking::begin_panic_handler::{{closure}}::hc552fcee62aad17f
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:497:13
  12:     0x55e20ffff3cc - std::sys_common::backtrace::__rust_end_short_backtrace::hb9f0aa9a78e885a0
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/sys_common/backtrace.rs:141:18
  13:     0x55e210000e89 - rust_begin_unwind
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:493:5
  14:     0x55e210014bd1 - core::panicking::panic_fmt::h12ac4570ea43d06f
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:92:14
  15:     0x55e2100149f3 - core::option::expect_none_failed::h096fa60f757b7204
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/option.rs:1268:5
  16:     0x55e20ffe880b - core::result::Result<T,E>::unwrap::h23ab59a6011dd489
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/result.rs:973:23
  17:     0x55e20ffe85c1 - closure::main::hd8478034164f6203
                               at /root/rs/closure/src/main.rs:4:14
  18:     0x55e20ffe895b - core::ops::function::FnOnce::call_once::h9502039bf2f2494b
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
  19:     0x55e20ffe8c4e - std::sys_common::backtrace::__rust_begin_short_backtrace::h8a370b3ebd3460e3
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/sys_common/backtrace.rs:125:18
  20:     0x55e20ffe8571 - std::rt::lang_start::{{closure}}::ha2ec106e59c08085
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/rt.rs:66:18
  21:     0x55e210001807 - core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &F>::call_once::h78040f802d89ccdc
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:259:13
  22:     0x55e210001807 - std::panicking::try::do_call::h6853cad536dd09a1
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:379:40
  23:     0x55e210001807 - std::panicking::try::h827495f03a9fbb9a
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:343:19
  24:     0x55e210001807 - std::panic::catch_unwind::h4bdf17571090eb17
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panic.rs:396:14
  25:     0x55e210001807 - std::rt::lang_start_internal::h2f319c33bb013f29
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/rt.rs:51:25
  26:     0x55e20ffe8547 - std::rt::lang_start::h99110ac3c9ee18ae
                               at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/rt.rs:65:5
  27:     0x55e20ffe860a - main
  28:     0x7fb5129560b3 - __libc_start_main
  29:     0x55e20ffe809e - _start
  30:                0x0 - <unknown>
```

生产环境可以对`ELF`进行`strip`处理，提升安全性。

> 枚举，可为成员绑定一个值。
>
> 如果不关心绑定值，可直接使用 is_ok、is_err 方法。
>

```rust
fn test(x: i32) -> Result<i32, &'static str> {
    if x > 0 { Ok(x) } else { Err("error") }
}

fn main() {
    match test(1) {
        Ok(x)  => println!("{:?}", x),
        Err(e) => println!("{:?}", e),
    }

    let _x = test(0).unwrap_or_else(|err| {  // unwrap, expect
        panic!("{:?}", err);
    });
}                                      
```

> 提示:
>   
>   * 如果频繁使用该Result类型，可以考虑创建更易懂的别名。
>   * 定义具体的错误类型更合理。


### Result实例

标准库中的许多文件操作API都会返回 `Result` 类型，因为可能存在不同的操作失败原因，例如找不到文件(file not found)、目录不存在(directory does not exists)，以及权限错误(permission errors)等。

```rust
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn main() {
    let path = Path::new("data.txt");
    let mut file = match File::open(&path) {
        Ok(file)    => file,
        Err(err)    => panic!("Error while opening file: {}", err),
    };

    let mut s = String::new();
    let _ = file.read_to_string(&mut s);
    println!("Message: {}", s);
}
```

&nbsp;

### 传播

可通过 `return Err`将错误按调用堆栈传递出去。

```rust
fn div(x: i32, y: i32) -> Result<i32, &'static str> {
    if y != 0 { 
        Ok(x / y) 
    } else { 
        Err("divide by zero") 
    }
}

fn test(x: i32, y: i32) -> Result<i32, &'static str> {
    let z = div(x, y);
    if z.is_err() { return z; }  // 传播！

    z
}


fn main() {
    test(3, 0).unwrap();        // 处理错误！
}                                      
```

&nbsp;

### 运算符 "?"

使用`?`来代替原来的`match`匹配的方式。`?`作用在函数的结束。

* 要么解构出`Ok`关联值，要么`return Err`向外传播。
* 只能用于`Result<T, E>`返回值的函数。
* 隐式传播的`Err`关键值类型必须相同，或可自动转换。

```rust
fn div(x: i32, y: i32) -> Result<i32, &'static str> {
    if y != 0 {
        Ok(x/ y)
    } else {
        Err("divide by zero")
    }
}

fn test(x: i32, y: i32) -> Result<i32, &'static str> {
    let z: i32 = div(x, y)?;            // z返回值为i32或者Err
                                        // 如果div函数结果正确，继续之后逻辑，直到程序结束

    Ok(z)                               // Ok将成功值，解构为Result进行返回
}

fn main() {
    test(3, 0).unwrap();
}
```

&nbsp;

### 链式调用

```rust
File.open("hello.txt")?.read_to_string(&mut s)?;
```